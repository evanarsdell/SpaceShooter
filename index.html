<!DOCTYPE html>

<html lang="en">

<head>

<meta charset="utf-8"/>

<title>Space Shooter 3D - Immersive Cockpit</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>

<meta name="apple-mobile-web-app-capable" content="yes"/>

<style>

html, body {

height: 100%;

margin: 0; padding: 0;

background: #080c20;

overflow: hidden;

touch-action: none;

user-select: none;

-webkit-user-select: none;

font-family: 'Orbitron', Arial, sans-serif;

}

#gameCanvas {

position: absolute;

width: 100vw; height: 100vh;

left: 0; top: 0; display: block;

z-index: 1;

background: #000e18;

touch-action: none;

}

#shootBtn {

position: absolute;

right: 7vw; bottom: 7vw;

width: 20vw; height: 20vw;

max-width: 100px; max-height: 100px;

min-width: 58px; min-height: 58px;

border-radius: 50%;

background: linear-gradient(145deg, #1ee4ff66 40%, #1483f744 100%);

border: 3px solid #2bf0ff;

color: #fff;

font-size: 2.5rem;

font-family: inherit;

font-weight: bold;

box-shadow: 0 3px 30px #51e8ff44, 0 4px 20px #0af0ed19 inset;

z-index: 11;

display: flex; align-items: center; justify-content: center;

transition: background 0.13s;

touch-action: none;

outline: none;

cursor: pointer;

opacity: 0.95;

backdrop-filter: blur(2px);

}

#shootBtn:active {

background: linear-gradient(145deg, #60ecffb5 60%, #1996ff88);

}

#scoreHud {

position: absolute; left: 3vw; top: 2.3vw;

z-index: 10;

background: #0c1a28dd;

color: #e3fcff;

padding: 0.3em 1em 0.3em 1.15em;

border-radius: 13px;

font-size: 1.29rem;

box-shadow: 0 2px 12px #11e8ff22, 0 1.5px 8px #12548f50 inset;

pointer-events: none;

border: 1.5px solid #24f3ff34;

letter-spacing: 0.1em;

}

#healthBar {

margin-top: .5em;

width: 96px;

height: 13px;

background: #164d5e88;

border-radius: 4px;

overflow: hidden;

border: 1.3px solid #40ffe973;

display: block;

}

#healthBar > div {

background: linear-gradient(90deg, #69ffb5 0%, #51e1fd 90%);

height: 100%;

border-radius: 3px;

box-shadow: 0 1.5px 12px #69ffb691;

transition: width 0.17s;

}

#centerCrosshair {

position: absolute;

left: 50%; top: 50%;

transform: translate(-50%, -50%);

pointer-events: none;

z-index: 11;

}

#centerCrosshair svg {

display: block; width: 52px; height: 52px;

opacity: 0.96;

}

#gameOverHud {

position: absolute; left: 50%; top: 45%; transform: translate(-50%,-55%);

z-index: 100;

min-width: 215px;

padding: 24px 32px 28px 32px;

background: rgba(8,17,27,.93);

color: #d2fffd;

font-size: 2.3rem;

border-radius: 19px;

box-shadow: 0 5.5px 70px #0de7fff6, 0 1.2px 16px #08232fcc;

text-align: center;

display: none;

user-select: none;

border: 2px solid #41f2ff33;

backdrop-filter: blur(5px);

}

#restartBtn {

margin-top: 1.35em;

font-size: 1.18rem;

font-weight: bold;

padding: 0.7em 1.7em;

border-radius: 11px;

border: none;

background: linear-gradient(100deg, #27e0ffbb 14%, #22aaff 93%);

color: #fff; letter-spacing: 0.05em;

box-shadow: 0 0 9px #13ecff84;

cursor: pointer;

outline: none;

font-family: inherit;

transition: background 0.14s;

}

#restartBtn:active { background: #1289dc; }

#permissionRequest {

position: absolute; left: 0; top: 0; width: 100vw; height: 100vh;

background: #000c;

color: #fff;

display: flex;

align-items: center; justify-content: center;

font-size: 1.28rem;

flex-direction: column;

z-index: 2000;

backdrop-filter: blur(2px);

user-select: none;

text-align: center;

}

#permissionBtn {

margin-top: 2em;

font-size: 1.23rem;

padding: 0.82em 2.2em;

background: #1eeeff;

color: #003242;

border: none;

border-radius: 11px;

font-weight: bold;

box-shadow: 0 0 13px #41e7ffb2, 0 6px 36px #2fdaff42;

letter-spacing: 0.04em;

cursor: pointer;

}

::-webkit-scrollbar {display:none;}

</style>

</head>

<body>

<canvas id="gameCanvas"></canvas>

<div id="scoreHud">

<span id="scoreField">SCORE: 0</span>

<div id="healthBar"><div></div></div>

</div>

<div id="centerCrosshair">

<svg viewBox="0 0 52 52">

<circle cx="26" cy="26" r="15" fill="none" stroke="#30edff" stroke-width="2.1"/>

<circle cx="26" cy="26" r="3.4" fill="#31cdff" fill-opacity="0.16" stroke="#11ffd1" stroke-width="1.2"/>

<path d="M22 26h-6" stroke="#50fefc" stroke-width="1.2" stroke-linecap="round"/>

<path d="M36 26h6" stroke="#50fefc" stroke-width="1.2" stroke-linecap="round"/>

<path d="M26 22v-6" stroke="#50fefc" stroke-width="1.2" stroke-linecap="round"/>

<path d="M26 36v6" stroke="#50fefc" stroke-width="1.2" stroke-linecap="round"/>

</svg>

</div>

<button id="shootBtn">ðŸ’¥</button>

<div id="permissionRequest" style="display:none;">

<div style="font-size:1.36em;font-weight:bold;">ðŸš€ Allow Motion Sensor Access</div>

<div style="margin-top:1em;max-width:85vw;font-size:1em;">

This game uses the accelerometer to steer and aim.<br>TAP ALLOW to enable controls.

</div>

<button id="permissionBtn">ALLOW</button>

</div>

<div id="gameOverHud">

<div id="gameOverText">CRASHED!</div>

<div id="finalScore" style="margin-top:.5em;color:#7fceff;font-size:1.1em;"></div>

<button id="restartBtn">RESTART</button>

</div>

<script>

/* ------------ Core state & settings ------------ */

const width = window.innerWidth, height = window.innerHeight;

const FOV = 75, Z_NEAR = 0.2, Z_FAR = 120;

const canvas = document.getElementById('gameCanvas');

const ctx = canvas.getContext('2d');

canvas.width = width; canvas.height = height;

function resizeCanvas() {

canvas.width = window.innerWidth;

canvas.height = window.innerHeight;

}

window.addEventListener('resize', resizeCanvas);

/* UI */

const shootBtn = document.getElementById('shootBtn');

const scoreField = document.getElementById('scoreField');

const healthBarInner = document.querySelector('#healthBar > div');

const permissionRequest = document.getElementById('permissionRequest');

const permissionBtn = document.getElementById('permissionBtn');

const gameOverHud = document.getElementById('gameOverHud');

const gameOverText = document.getElementById('gameOverText');

const finalScore = document.getElementById('finalScore');

const restartBtn = document.getElementById('restartBtn');

/* --- Player Ship State --- */

const player = {

x: 0, y: 0, z: 4,

// ship aim by rotX/pitch & rotY/yaw, in radians

rotX: 0, rotY: 0,

// actual ship trajectory for smooth movement

targetX: 0, targetY: 0, targetZ: 4,

vspeed: 1.2,

inertia: 0.13, // position lerp

aimSmooth: 0.19, // for feel

maxTiltAngle: 1.02,

zeroTiltX: 0, zeroTiltY: 0,

health: 1,

lastLaser: 0,

score: 0,

dead: false,

invuln: 0

};

/* --- World / Entities --- */

let asteroids = [];

let debris = [];

let enemies = [];

let lasers = [];

let explosions = [];

let crashAnim = 0;

/* --- Starfield for depth effect --- */

let starfield = [];

const STAR_COUNT = Math.min(180, Math.floor(width*height/900));

function genStarfield() {

starfield = [];

for(let i=0;i<STAR_COUNT;++i) {

starfield.push({

x: (Math.random()*2-1)*15,

y: (Math.random()*2-1)*10,

z: Math.random()*70+10,

c: (Math.random()>0.75)?'#fff':(Math.random()>0.45?'#c3f7ff':'#eafcff')

});

}

}

genStarfield();

/* --- World difficulty values --- */

let asteroidSpeed = 8.2, asteroidInterval = 900, debrisInterval = 1200, enemyInterval = 2750;

let lastAsteroid = 0, lastDebris = 0, lastEnemy = 0;

/* --- Motion/Touch Input --- */

let tiltAvailable = false, neutralized = false;

let beta = 0, gamma = 0, alpha = 0; // Raw

function handleTilt(b, g) {

if (!neutralized) return;

// Use offset-calibrated tilt, in radians

let dx = (g - player.zeroTiltX) * Math.PI/180;

let dy = (b - player.zeroTiltY) * Math.PI/180;

dx = Math.max(-player.maxTiltAngle, Math.min(player.maxTiltAngle, dx));

dy = Math.max(-player.maxTiltAngle, Math.min(player.maxTiltAngle, dy));

// Use inertia for natural camera aim

player.rotY += (dx - player.rotY) * player.aimSmooth;

player.rotX += (dy - player.rotX) * player.aimSmooth;

}

function setupMotion() {

tiltAvailable = true;

window.addEventListener('deviceorientation', function (e) {

beta = e.beta; gamma = e.gamma; alpha = e.alpha;

handleTilt(beta, gamma);

}, true);

}

function calibrateTilt() {

player.zeroTiltX = gamma || 0;

player.zeroTiltY = beta || 0;

neutralized = true;

}

function requestMotionPermissionIfNeeded(){

let needPerm = window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === 'function';

if(needPerm){

permissionRequest.style.display = 'flex';

permissionBtn.onclick = function(){

DeviceMotionEvent.requestPermission().then(function(state){

if(state==='granted'){

permissionRequest.style.display = 'none';

setupMotion();

}

});

}

} else {

setupMotion();

permissionRequest.style.display = 'none';

}

};

requestMotionPermissionIfNeeded();

// Allow tap anywhere to calibrate center

window.addEventListener('touchstart',function(){

calibrateTilt();

},{passive:true});

/* --- GAME OVER/RESTART --- */

restartBtn.onclick = resetGame;

function endGame(reason) {

player.dead = true;

setTimeout(()=> {

gameOverHud.style.display = 'block';

gameOverText.textContent = reason||'Crashed!';

finalScore.innerHTML = `FINAL SCORE<br /><span style="color:#beeeff;font-size:1.38em;">${Math.floor(player.score)}</span>`;

}, 950);

}

/* --- LASER DIRECTION: Always matches current camera aim --- */

function getAimDir() {

// Use normalized direction vector from camera (rotX/Y)

const sinX = Math.sin(player.rotX), cosX = Math.cos(player.rotX);

const sinY = Math.sin(player.rotY), cosY = Math.cos(player.rotY);

const dx = sinY * cosX;

const dy = sinX;

const dz = cosY * cosX;

const len = Math.sqrt(dx*dx+dy*dy+dz*dz);

return {dx:dx/len, dy:dy/len, dz:dz/len};

}

function fireLaser(evt) {

if (player.dead) return;

(evt && evt.preventDefault && evt.preventDefault());

const now = performance.now()/1000;

if (now - player.lastLaser < 0.19) return;

player.lastLaser = now;

const {dx,dy,dz} = getAimDir();

lasers.push({

x: player.x, y: player.y, z: player.z+0.5,

dx, dy, dz,

t: now

});

playLaserSound();

}

shootBtn.addEventListener('touchstart', fireLaser, {passive:false});

shootBtn.addEventListener('mousedown', fireLaser);

/* --- SFX (Web Audio, pure JS) --- */

let audioCtx = null;

function playLaserSound(){

try{

window.AudioContext = window.AudioContext||window.webkitAudioContext;

audioCtx = audioCtx || new AudioContext();

const o = audioCtx.createOscillator();

const g = audioCtx.createGain();

o.type = 'triangle';

o.frequency.setValueAtTime(920, audioCtx.currentTime);

o.frequency.linearRampToValueAtTime(1680, audioCtx.currentTime+0.07);

o.frequency.linearRampToValueAtTime(430, audioCtx.currentTime+0.15);

g.gain.setValueAtTime(0.22, audioCtx.currentTime);

g.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime+0.19);

o.connect(g); g.connect(audioCtx.destination);

o.start(); o.stop(audioCtx.currentTime+0.19);

}catch(e){}

}

function playExplosionSound(){

try{

audioCtx = audioCtx || (window.AudioContext?new AudioContext():null);

if (!audioCtx) return;

const o = audioCtx.createOscillator();

const g = audioCtx.createGain();

o.type = 'sawtooth'; g.gain.value=0.3;

o.frequency.setValueAtTime(190,audioCtx.currentTime);

o.frequency.linearRampToValueAtTime(44,audioCtx.currentTime+0.31);

g.gain.setValueAtTime(.25, audioCtx.currentTime);

g.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime+0.36);

o.connect(g); g.connect(audioCtx.destination);

o.start(); o.stop(audioCtx.currentTime+0.36);

}catch(e){}

}

function playCrashSound(){

try {

audioCtx = audioCtx || (window.AudioContext?new AudioContext():null);

if (!audioCtx) return;

const o = audioCtx.createOscillator();

const g = audioCtx.createGain();

o.type = "square"; g.gain.value=0.4;

o.frequency.setValueAtTime(410,audioCtx.currentTime);

o.frequency.linearRampToValueAtTime(62,audioCtx.currentTime+0.23);

g.gain.setValueAtTime(.33, audioCtx.currentTime);

g.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime+0.26);

o.connect(g); g.connect(audioCtx.destination);

o.start(); o.stop(audioCtx.currentTime+0.27);

}catch(e){}

}

/* --- ENTITIES --- */

function spawnAsteroid() {

const radius = Math.random()*2.1+1.1;

const theta = (Math.random()-0.5) * Math.PI*0.7;

const phi = (Math.random()-0.5) * Math.PI/4;

let dist = 40 + Math.random()*32;

let fx = Math.sin(theta) * dist;

let fy = Math.sin(phi) * dist;

let fz = Math.cos(theta) * dist;

let vx = (Math.random()-0.5)*0.19;

let vy = (Math.random()-0.5)*0.19;

let vz = -(asteroidSpeed*0.95 + Math.random()*asteroidSpeed*0.13);

asteroids.push({

x: player.x + fx, y: player.y + fy, z: player.z + fz,

radius: radius,

rot: [Math.random()*Math.PI*2, Math.random()*Math.PI*2],

rotSpeed: [(Math.random()-0.5)*1.1, (Math.random()-0.5)*.7],

colorTone: 0.54 + Math.random()*0.35,

vx, vy, vz

});

}

function spawnDebris() {

const size = 0.43+Math.random()*0.6;

const angle = (Math.random()-0.5) * Math.PI;

let dist = 32 + Math.random()*55;

let fx = Math.sin(angle) * dist;

let fy = (Math.random()-0.5)*10.5;

let fz = Math.cos(angle) * dist;

debris.push({

x: player.x + fx, y: player.y + fy, z: player.z + fz,

radius: size,

rot: [Math.random()*Math.PI*2],

rotSpeed: [(Math.random()-0.5)*2.1],

color: (Math.random()>0.64)?'#7cb2ae':'#c8e1fb',

vx: (Math.random()-0.5)*0.19,

vy: (Math.random()-0.5)*0.18,

vz: -(asteroidSpeed*0.69 + Math.random()*asteroidSpeed*0.33)

});

}

function spawnEnemy() {

const dist = 56 + Math.random()*31;

const h = (Math.random()-0.5) * Math.PI*0.85;

let fx = Math.sin(h) * dist;

let fy = (Math.random()-0.5) * 6.7;

let fz = Math.cos(h) * dist;

enemies.push({

x: player.x+fx, y: player.y+fy, z: player.z+fz,

radius: 1.3+Math.random()*1.3,

rot: (Math.random()-0.5)*Math.PI,

speed: -(asteroidSpeed*0.97 + Math.random()*asteroidSpeed*0.12),

health: 2

});

}

/* --- PROJECTION --- */

function project3D(wx,wy,wz){

let dx = wx-player.x, dy = wy-player.y, dz = wz-player.z;

let cy = Math.cos(-player.rotY), sy = Math.sin(-player.rotY);

let x = cy*dx - sy*dz;

let z = sy*dx + cy*dz;

let cx = Math.cos(-player.rotX), sx = Math.sin(-player.rotX);

let y = cx*dy - sx*z;

z = sx*dy + cx*z;

if(z < Z_NEAR) return null;

const f = 0.58*height / Math.tan(FOV * Math.PI/360);

let px = width/2 + x/z * f;

let py = height/2 + y/z * f*0.98;

return {x:px, y:py, z:z};

}

/* --- COLLISIONS --- */

function segmentSphereHit(l, segLen, obj, rad){

let p1=[l.x,l.y,l.z], p2=[l.x+l.dx*segLen,l.y+l.dy*segLen,l.z+l.dz*segLen];

let c=[obj.x,obj.y,obj.z];

let ab=[p2[0]-p1[0],p2[1]-p1[1],p2[2]-p1[2]];

let ac=[c[0]-p1[0],c[1]-p1[1],c[2]-p1[2]];

let ab2 = ab[0]*ab[0]+ab[1]*ab[1]+ab[2]*ab[2];

let t = ab2!==0?(

(ac[0]*ab[0]+ac[1]*ab[1]+ac[2]*ab[2])/ab2

):0;

t = Math.max(0,Math.min(1,t));

let cx=p1[0]+ab[0]*t, cy=p1[1]+ab[1]*t, cz=p1[2]+ab[2]*t;

let dd=(cx-c[0])**2+(cy-c[1])**2+(cz-c[2])**2;

return dd < rad*rad;

}

function sphereDistance(a,ra,b,rb){

let dx = a.x-b.x, dy=a.y-b.y, dz=a.z-b.z;

return Math.sqrt(dx*dx+dy*dy+dz*dz) - (ra+rb);

}

/* --- DRAW 3D ENTITIES --- */

function renderStarfield(){

for(let s of starfield){

let z = s.z;

let offX = s.x + player.rotY*25;

let offY = s.y + player.rotX*28;

let pr = project3D(player.x+offX, player.y+offY, player.z+z);

if(!pr) continue;

let size = 0.7 + 4.9/(pr.z+2);

ctx.globalAlpha = Math.max(0.13, 0.45/(pr.z*0.19));

ctx.fillStyle = s.c;

ctx.beginPath();

ctx.arc(pr.x, pr.y, size, 0, 2*Math.PI);

ctx.fill();

}

ctx.globalAlpha=1;

}

function renderAsteroids(){

for(let a of asteroids){

let pr = project3D(a.x,a.y,a.z); if(!pr) continue;

let rad = a.radius * (height/19)/pr.z;

ctx.save(); ctx.translate(pr.x,pr.y);

let color = `rgba(${70+a.colorTone*95},${80+a.colorTone*55},${93*a.colorTone+20},0.96)`;

ctx.beginPath();

ctx.arc(0,0,rad,0,2*Math.PI);

ctx.fillStyle=color;

ctx.shadowColor="#3a3b33";

ctx.shadowBlur=rad*0.4;

ctx.fill();

// craters

ctx.globalAlpha=0.24;

for(let i=0;i<6;i++){

ctx.beginPath();

let ang = i*2*Math.PI/6 + a.rot[0];

ctx.arc(Math.cos(ang)*rad*0.56, Math.sin(ang)*rad*0.58, rad*0.22, 0, 2*Math.PI);

ctx.fillStyle = "#181816";

ctx.fill();

}

ctx.globalAlpha=1;

ctx.restore();

a.rot[0]+=a.rotSpeed[0]*0.029;

a.rot[1]+=a.rotSpeed[1]*0.025;

}

}

function renderDebris(){

for(let d of debris){

let pr = project3D(d.x,d.y,d.z); if(!pr) continue;

let rad = d.radius * (height/32)/pr.z;

ctx.save(); ctx.translate(pr.x,pr.y); ctx.rotate(d.rot[0]);

ctx.fillStyle = d.color; ctx.globalAlpha=0.74;

ctx.beginPath();

ctx.moveTo(0,-rad*1.18); ctx.lineTo(rad*0.66,rad*0.85); ctx.lineTo(-rad*0.6,rad*0.7); ctx.closePath();

ctx.fill(); ctx.globalAlpha=1; ctx.restore();

d.rot[0]+=d.rotSpeed[0]*0.04;

}

}

function renderEnemies(){

for(let e of enemies){

let pr = project3D(e.x,e.y,e.z); if(!pr) continue;

let rad = e.radius * (height/16)/pr.z;

ctx.save();

ctx.translate(pr.x,pr.y); ctx.rotate(e.rot);

ctx.beginPath();

ctx.moveTo(0,-rad*1.05);

ctx.lineTo(rad*0.8,rad*1);

ctx.lineTo(-rad*0.8,rad*1);

ctx.closePath();

ctx.fillStyle = "#4ff8fa";

ctx.shadowColor = "#00e0e7";

ctx.shadowBlur = 8;

ctx.globalAlpha = 0.81;

ctx.fill();

ctx.beginPath(); ctx.arc(0,0, rad*0.41,0,2*Math.PI);

ctx.globalAlpha=0.33; ctx.fillStyle="#fff";

ctx.fill();

ctx.restore();

}

}

function renderLasers(){

for(let l of lasers){

const len = 2.5;

let prj1 = project3D(l.x, l.y, l.z);

let prj2 = project3D(l.x+l.dx*len, l.y+l.dy*len, l.z+l.dz*len);

if(!prj1||!prj2) continue;

ctx.save();

let grad = ctx.createLinearGradient(prj1.x,prj1.y,prj2.x,prj2.y);

grad.addColorStop(0,"#fff");

grad.addColorStop(0.4,"#19f2ff");

grad.addColorStop(1,"#11eaff");

ctx.strokeStyle=grad;

ctx.lineWidth = 2.4 + 4/(0.65+prj1.z);

ctx.shadowColor="#21eaff";

ctx.shadowBlur=8;

ctx.beginPath();

ctx.moveTo(prj1.x,prj1.y);

ctx.lineTo(prj2.x,prj2.y);

ctx.stroke();

ctx.globalAlpha=0.19;

ctx.beginPath();

ctx.arc(prj1.x,prj1.y, ctx.lineWidth*1.6, 0, 2*Math.PI);

ctx.fillStyle="#d2efff"; ctx.fill();

ctx.globalAlpha=1; ctx.restore();

}

}

function renderExplosions(){

for(let e of explosions){

let t = Math.min(1, e.age/0.38);

let pr = project3D(e.x, e.y, e.z); if(!pr) continue;

let R = e.r / (1+t*1.3) * (height/25)/pr.z;

ctx.save();

let grd = ctx.createRadialGradient(pr.x,pr.y,0,pr.x,pr.y,R);

grd.addColorStop(0,"#ffe");

grd.addColorStop(0.22,"#ffd598");

grd.addColorStop(0.53,"#f97d34");

grd.addColorStop(1,"rgba(220,70,30,0)");

ctx.globalAlpha=1-t;

ctx.beginPath();

ctx.arc(pr.x,pr.y,R,0,2*Math.PI);

ctx.fillStyle=grd; ctx.fill();

ctx.restore();

}

}

function renderCockpit(){

ctx.save();

const w = canvas.width, h = canvas.height;

// Glass frame overlay

ctx.globalAlpha = 0.75;

ctx.strokeStyle = "#23f8ff";

ctx.lineWidth = Math.max(2, w*0.012);

ctx.beginPath();

ctx.ellipse(w/2, h*0.56, w*0.39, h*0.33, 0, 0, Math.PI, true);

ctx.stroke();

// Dashboard panel

let dashH = h*0.155;

ctx.globalAlpha = .82;

let grd = ctx.createLinearGradient(0,h-dashH,0,h);

grd.addColorStop(0,"rgba(19,43,59,0.97)"); grd.addColorStop(0.6,"#1e2a36");

grd.addColorStop(1,"#03151c");

ctx.fillStyle=grd;

ctx.beginPath();

ctx.moveTo(w*0.13,h-dashH*0.1);

ctx.lineTo(w*0.17,h-dashH*0.61);

ctx.bezierCurveTo(w*0.27,h-dashH*1.07, w*0.73,h-dashH*1.07, w*0.83,h-dashH*0.61);

ctx.lineTo(w*0.87, h-dashH*0.1);

ctx.lineTo(w*0.13,h-dashH*0.1);

ctx.closePath(); ctx.fill();

ctx.restore();

}

/* --- MAIN LOOP --- */

let lastFrame = null;

function resetGame(){

player.x = 0; player.y = 0; player.z = 4;

player.rotX = 0; player.rotY = 0; player.health = 1; player.dead=false; player.score=0;

player.targetX = 0; player.targetY = 0; player.targetZ = 4; player.invuln=0;

asteroids = []; debris = []; enemies = []; lasers = []; explosions = [];

lastAsteroid=0; lastDebris=0; lastEnemy=0; asteroidSpeed = 8.2; asteroidInterval=900; debrisInterval=1200; enemyInterval=2750;

gameOverHud.style.display = 'none';

crashAnim = 0; genStarfield();

lastFrame=null; requestAnimationFrame(gameLoop);

}

function gameLoop(now){

if(player.dead) { renderCrash(crashAnim||0.5); return; }

let t = now/1000;

if (!lastFrame) lastFrame = t;

let dt = Math.max(0.008, Math.min(0.045, t-lastFrame));

lastFrame = t;

// Difficulty

asteroidInterval=880-Math.min(468,player.score*0.09);

debrisInterval = 1190-Math.min(600,player.score*0.06);

enemyInterval = 2410 - Math.min(1100,player.score*0.04);

asteroidSpeed = 8.2 + player.score*0.0021;

// Ship smooth movement: ship "follows" pointer, with inertia

let aim = getAimDir();

player.targetX += aim.dx * player.vspeed * dt * .95;

player.targetY += aim.dy * player.vspeed * dt * .94;

player.targetZ += aim.dz * player.vspeed * dt * 0.95;

// Clamp to avoid lost in space

player.targetX=Math.max(-20,Math.min(20,player.targetX));

player.targetY=Math.max(-11,Math.min(11,player.targetY));

// Ship position lerps toward 'target', i.e. mass/inertia

player.x += (player.targetX-player.x)*player.inertia;

player.y += (player.targetY-player.y)*player.inertia;

player.z += (player.targetZ-player.z)*player.inertia*0.7;

// Spawn Entities

const nowMs = now;

if(nowMs-lastAsteroid > asteroidInterval && asteroids.length < 7){

spawnAsteroid(); lastAsteroid = nowMs;

}

if(nowMs-lastDebris > debrisInterval && debris.length<7){

spawnDebris(); lastDebris = nowMs;

}

if(enemies.length<2 && nowMs-lastEnemy>enemyInterval){

spawnEnemy(); lastEnemy=nowMs;

}

// Move things

for(let a of asteroids){

a.x+=a.vx*dt; a.y+=a.vy*dt; a.z+=a.vz*dt;

}

for(let d of debris) {

d.x+=d.vx*dt; d.y+=d.vy*dt; d.z+=d.vz*dt;

}

for(let e of enemies){

e.z+=e.speed*dt;

}

asteroids = asteroids.filter(a=>a.z>Z_NEAR && Math.abs(a.x-player.x)<25 && Math.abs(a.y-player.y)<15);

debris = debris.filter(d=>d.z>Z_NEAR && Math.abs(d.x-player.x)<33);

enemies = enemies.filter(e => e.z>Z_NEAR && Math.abs(e.x-player.x)<29);

// Lasers

for(let l of lasers){

l.x+=l.dx*63*dt; l.y+=l.dy*63*dt; l.z+=l.dz*63*dt;

}

lasers = lasers.filter(l=>l.z>Z_NEAR&&l.z<Z_FAR);

// COLLISIONS

// Laser - asteroid

for(let li=lasers.length-1;li>=0;li--){

let l=lasers[li];

for(let ai=asteroids.length-1;ai>=0;ai--){

let a=asteroids[ai];

if(segmentSphereHit(l,2.5,a,a.radius)){

player.score+=Math.floor(9*a.radius);

explosions.push({x:a.x,y:a.y,z:a.z,r:a.radius*1.6,age:0});

playExplosionSound(); asteroids.splice(ai,1); lasers.splice(li,1); break;

}

}

// Laser-debris : just pass through

for(let ei=enemies.length-1;ei>=0;ei--){

let e=enemies[ei];

if(segmentSphereHit(l,2.4,e,e.radius*.95)){

e.health-=1; explosions.push({x:e.x,y:e.y,z:e.z,r:e.radius*2,age:0});

playExplosionSound(); player.score+=30; lasers.splice(li,1);

if(e.health<=0) enemies.splice(ei,1);

break;

}

}

}

// Animate explosions

for(let ex of explosions) ex.age+=dt;

explosions = explosions.filter(e=>e.age<.48);

// Object/ship coll

if(player.invuln<=0){

for(let a of asteroids){

if(sphereDistance(player,1.2,a,a.radius*0.96)<0){

crashAnim=0; explosions.push({x:a.x,y:a.y,z:a.z,r:a.radius*1.6,age:0});

playCrashSound(); setTimeout(()=>endGame("CRASHED INTO ASTEROID!"),800);

player.health = 0; player.dead=true; return;

}

}

for(let d of debris){

if(sphereDistance(player,1.15,d,d.radius*1.1)<0){

player.health -= .15; player.invuln=0.7;

if(player.health<=0){

crashAnim=0; explosions.push({x:d.x,y:d.y,z:d.z,r:d.radius*1.6,age:0});

playCrashSound(); setTimeout(()=>endGame("DESTROYED BY DEBRIS!"),800);

player.health=0; player.dead=true; return;

}

explosions.push({x:d.x,y:d.y,z:d.z,r:d.radius*1.0,age:0});

debris.splice(debris.indexOf(d),1);

}

}

for(let e of enemies){

if(sphereDistance(player,1.23,e,e.radius*0.9)<0){

crashAnim=0; explosions.push({x:e.x,y:e.y,z:e.z,r:e.radius*2,age:0});

playCrashSound(); setTimeout(()=>endGame("COLLIDED WITH ENEMY!"),800);

player.health = 0; player.dead=true; return;

}

}

} else { player.invuln-=dt;}

// HUD

healthBarInner.style.width = Math.max(0,player.health*100)+'%';

scoreField.innerText = `SCORE: ${Math.floor(player.score)}`;

// DRAW

ctx.clearRect(0,0,canvas.width,canvas.height);

renderStarfield(); renderAsteroids(); renderDebris(); renderEnemies(); renderLasers(); renderExplosions(); renderCockpit();

// Vignette

ctx.save();

let vGrd=ctx.createRadialGradient(width/2, height/2, height*0.62, width/2,height/2, height*1.17);

vGrd.addColorStop(0,"rgba(0,0,0,0)");

vGrd.addColorStop(1,"rgba(0,0,0,0.19)");

ctx.globalAlpha=1; ctx.fillStyle=vGrd; ctx.fillRect(0,0,width,height);

ctx.restore();

// Crash overlay

if(player.dead){ renderCrash(crashAnim||0); return;}

if(crashAnim!==null){ crashAnim+=dt; if(crashAnim>0.48) crashAnim=null; }

requestAnimationFrame(gameLoop);

}

function renderCrash(anim){

let p = Math.min(1,anim/0.44);

ctx.save();

ctx.globalAlpha = .52*(1-p); ctx.fillStyle="#fff";

ctx.fillRect(0,0,width,height);

ctx.globalAlpha = .22*p; ctx.fillStyle="#e14";

ctx.fillRect(0,0,width,height);

ctx.restore();

}

resetGame();

</script>

</body>

</html>

