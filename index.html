<!DOCTYPE html>

<html lang="en">

<head>

<meta charset="UTF-8">

<title>Space Shooter: First Person Mobile</title>

<style>

html, body {

width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;

background: linear-gradient(#060b18, #23364f 70%, #2a4067 100%);

touch-action: none;

-webkit-touch-callout: none;

-webkit-user-select: none;

user-select: none;

}

#gameCanvas {

display: block;

position: absolute;

width: 100vw;

height: 100vh;

left: 0; top: 0; pointer-events: none;

touch-action: none;

background: rgba(12,18,28,0.98);

z-index: 1;

}

#touchLayer {

position: absolute; left: 0; top: 0; width: 100vw; height: 100vh;

z-index: 3; pointer-events: none;

}

.shoot-btn {

position: absolute; right: 5vw; bottom: 6vh; width: 22vw; height: 22vw;

max-width: 120px; max-height: 120px;

opacity: 0.7; border-radius: 50%; background: linear-gradient(145deg, #3f94c8 60%, #1b2852);

outline: none; border: 2px solid #5abdfa;

font-family: "Orbitron", monospace, Arial; font-size: 1.2em; color: #e0f6ff;

box-shadow: 0 4px 32px #122d5370, 0 2px 8px #000c2b8a;

pointer-events: auto; touch-action: manipulation;

transition: background 0.12s, box-shadow 0.12s;

font-weight: bold; letter-spacing: 0.1em;

}

.shoot-btn:active { opacity: 1; background: #56aff1; box-shadow: 0 0 16px #6defff;}

#permOverlay,

#gameOverOverlay,

#calibOverlay {

position: absolute; z-index: 10; top:0; left:0;

width:100vw;height:100vh; display:flex; align-items:center; justify-content: center;

background: rgba(12, 30, 45, 0.96);

font-family: "Orbitron", monospace, Arial; color: #e8f4ff;

flex-direction: column; font-size: 1.2em;

text-align: center;

pointer-events: auto;

}

h1 {

font-family: 'Orbitron', monospace;

color: #6edaff; margin-bottom: 0.1em;

text-shadow: 0px 2px 14px #07275aaf;

letter-spacing: 0.05em;

}

/* Responsive cockpit/HUD/crosshair won't overlap shoot button */

</style>

</head>

<body>

<canvas id="gameCanvas"></canvas>

<div id="touchLayer"></div>

<button class="shoot-btn" id="shootBtn">FIRE</button>

<!-- Motion/perm, Game Over, Calibration overlays, all hidden by default -->

<div id="permOverlay" style="display:none;">

<h1>SPACE SHOOTER</h1>

<div style="margin:1.4em 0;">

<b style="font-size: 1.23em;">Enable "Device Motion" to Play</b><br>

<span style="font-size:0.98em; color:#a8e2ff;">

On iPhone/iPad: Tap below to allow motion controls.<br>

Hold device roughly as you would to aim.<br>

</span>

</div>

<button id="permBtn" style="

background:#34b4f4;border:none;color:white;font-size:1.2em;padding:0.65em 2em;

margin-top:1em;border-radius:8px;box-shadow:0 2px 16px #179ff6;">

Enable Motion

</button>

<div style="margin-top:2em;color:#fff5;max-width:80vw;">v1.0 - All code procedural &amp; open source</div>

</div>

<div id="calibOverlay" style="display:none;">

<h1>Calibration</h1>

<div style="margin-bottom:1em;">Hold your device pointing "forward".<br> Tap to calibrate your aim baseline.</div>

<button id="calibBtn" style="

background:#5ecade;border:none;color:white;font-size:1.1em;padding:0.5em 2em;

border-radius:8px;box-shadow:0 2px 16px #32e8ca;">

Set Forward

</button>

</div>

<div id="gameOverOverlay" style="display:none;">

<h1>GAME OVER</h1>

<div id="finalScore" style="font-size:1.2em;margin-bottom:1.5em;"></div>

<button id="restartBtn" style="background:#268afb;border:none;color:white;

font-size:1.1em;padding:0.5em 2em;border-radius:8px;

box-shadow:0 2px 16px #2564e0;">

TAP TO RESTART

</button>

</div>

<script>

/* =========================

SPACE SHOOTER 3D FP (MOBILE)

All code is in this file. By @jdanek920, 2024.

========================= */

// ========== CONFIGURATION ==========

const CFG = {

starCount: 70,

astMinSize: 18, // screen px radius

astMaxSize: 40,

asteroidSpeed: 4.0, // units/second (z-)

asteroidFreq: 0.7, // spawn/sec (becomes harder)

laserSpeed: 16,

laserRadius: 3.4,

explosionFrames: 17,

playerMaxHealth: 5,

damageOnHit: 1,

laserCooldown: 0.18, // seconds

shootBtnSize: 0.21, // of min(screenW,screenH)

cockpitH: 0.22, // fraction of canvas height used by HUD

fov: 74, // camera FOV, deg

sensitivity: 0.88, // tilt-to-rotation sensitivity, radian

aimFilter: 0.17, // smoothing; bigger=slower, range 0..1

crosshairSize: 0.07,

recoilKick: 0.08, // crosshair "wiggle" when firing

maxAsteroids: 7,

asteroidColors: [

"#6d98af", "#9e8e6c", "#bbbbbb", "#50607a", "#646b7f", "#b96050"

]

};

// ========== GLOBAL STATE ==========

let canvas, ctx, dpr=1, W=1, H=1, cx=0, cy=0, minWH=1;

let camYaw=0, camPitch=0, tmpYaw=0, tmpPitch=0, targetYaw=0, targetPitch=0;

let aimRecoil=0;

// Device orientation, in degrees

let lastDeviceBeta=0, lastDeviceGamma=0, lastDeviceAlpha=0, haveMotion=false;

let initialPitch=0, initialYaw=0, initialSet=false;

let devicePermGranted=false, orientationActive=false;

// Game state

let playing=false, gameOver=false, calibrating=false;

let tLast=0, acc=0, gameSpeed=1.0;

let score=0, health=CFG.playerMaxHealth, asteroids=[], lasers=[], explosions=[], stars=[];

let lastLaserTime=0, asteroidTimer=0, asteroidLevel=1;

let crosshairJitter={x:0, y:0, frames:0};

// Audio context

let sfxCtx=null;

// ========== UI ELEMENTS ==========

const shootBtn = document.getElementById('shootBtn');

const permOverlay = document.getElementById('permOverlay');

const permBtn = document.getElementById('permBtn');

const calibOverlay = document.getElementById('calibOverlay');

const calibBtn = document.getElementById('calibBtn');

const gameOverOverlay = document.getElementById('gameOverOverlay');

const finalScore = document.getElementById('finalScore');

const restartBtn = document.getElementById('restartBtn');

// ========== UTILS ==========

const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

const rand = (a,b)=>a+(b-a)*Math.random();

const lerp = (a,b,t)=>a+(b-a)*t;

function hsv(h,s,v) {

h%=360; s=clamp(s,0,1); v=clamp(v,0,1);

let k=(n)=>(n+h/60)%6, f=(n)=>v-v*s*Math.max(Math.min(k(n),4-k(n),1),0);

return `rgb(${255*f(5)|0},${255*f(3)|0},${255*f(1)|0})`;

}

// ========== CANVAS INIT ==========

function resizeCanvas() {

dpr = window.devicePixelRatio || 1;

W = innerWidth; H = innerHeight; cx = W/2; cy = H/2;

minWH = Math.min(W,H);

canvas.width = W*dpr;

canvas.height = H*dpr;

canvas.style.width = W+'px';

canvas.style.height = H+'px';

ctx.setTransform(1,0,0,1,0,0); // reset

ctx.scale(dpr,dpr);

// Adjust button/cockpit

shootBtn.style.width = shootBtn.style.height =

Math.floor(CFG.shootBtnSize*minWH)+'px';

shootBtn.style.right = (0.05*W)+'px';

shootBtn.style.bottom = Math.floor(0.06*H)+'px';

}

function disableDefaultGestures() {

document.body.addEventListener('touchmove', e=>e.preventDefault(), {passive:false});

document.body.addEventListener('gesturestart', e=>e.preventDefault(), {passive:false});

}

// ========== EVENT: DEVICE ORIENTATION INPUT ==========

function requestDevicePermissionIfNeeded() {

// iOS 13+ needs user gesture for DeviceOrientationEvent

if (typeof DeviceOrientationEvent==="undefined") {

showPermOverlay('<b>Motion controls not supported.</b><br>Use a compatible browser & phone.');

return;

}

if (typeof DeviceOrientationEvent.requestPermission==="function") {

permOverlay.style.display='flex';

permBtn.onclick = function(){

DeviceOrientationEvent.requestPermission().then(res=>{

if(res==="granted") {

devicePermGranted=true;

permOverlay.style.display='none';

startCalibration();

} else {

showPermOverlay('<b>Please enable in iOS Settings &gt; Safari &gt; Motion</b>');

}

}).catch(()=>showPermOverlay("Device motion not enabled."));

}

permOverlay.style.display='flex';

} else {

// Android Chrome: no prompt, just use

devicePermGranted=true;

startCalibration();

}

}

function handleDeviceOrientation(e) {

haveMotion = true;

lastDeviceBeta = e.beta || 0;

lastDeviceGamma= e.gamma || 0;

lastDeviceAlpha= e.alpha || 0;

}

function showPermOverlay(msgHTML) {

permOverlay.style.display='flex';

if(msgHTML) permOverlay.children[1].innerHTML = msgHTML;

}

function startCalibration() {

calibrating=true;

calibOverlay.style.display='flex';

}

function doCalibration() {

// See Apple docs: beta = pitch (-180..180), gamma = roll (-90..90)

// We'll treat (beta,gamma) as calibration target.

// The zero point is forward: device screen perpendicular.

initialPitch = lastDeviceBeta || 0;

initialYaw = lastDeviceGamma || 0;

initialSet = true;

calibrating=false;

calibOverlay.style.display='none';

}

function recalibrate() {

startCalibration();

}

window.addEventListener('deviceorientation', handleDeviceOrientation, true);

// ========== INPUT HANDLING (MOBILE BUTTONS) ==========

let shooting=false;

shootBtn.addEventListener('touchstart', e=>{

shooting=true; shootBtn.focus();

e.preventDefault(); e.stopPropagation();

}, {passive:false});

shootBtn.addEventListener('mousedown', e=>{

shooting=true;

e.preventDefault(); e.stopPropagation();

});

["touchend","touchcancel","touchmove"].forEach(ev=>

shootBtn.addEventListener(ev,()=>shooting=false,{passive:false}));

["mouseup","mouseleave"].forEach(ev=>

shootBtn.addEventListener(ev,()=>shooting=false)

);

// Recalibration: tap cockpit below screen center

document.getElementById('gameCanvas').addEventListener('touchstart',e=>{

if (!playing && !calibrating && !gameOver) return;

let ty = e.touches[0].clientY;

if (ty > 0.78*H) recalibrate();

}, {passive:true});

// ========== UI EVENT: CALIBRATION & RESTART ==========

calibBtn.onclick = doCalibration;

restartBtn.onclick = function() { resetGame(true); gameOverOverlay.style.display='none'; };

window.addEventListener('orientationchange', ()=>setTimeout(resizeCanvas,50));

// ========== GAME INIT ==========

function resetGame(hard) {

asteroids.length=0; lasers.length=0; explosions.length=0; stars.length=0;

score=0; health=CFG.playerMaxHealth; lastLaserTime=0; asteroidTimer=0; asteroidLevel=1;

camYaw=camPitch=targetYaw=targetPitch=0;

aimRecoil=0; crosshairJitter.x=crosshairJitter.y=0; crosshairJitter.frames=0;

gameOver = false; playing = true;

if(hard) { initialSet=false; startCalibration(); }

// Generate background starfield

for(let i=0; i<CFG.starCount; ++i) {

let r = rand(0.7,1.1)*(minWH*0.004);

stars[i] = {

x: rand(-0.57,0.57)*W,

y: rand(-0.57,0.57)*H,

z: rand(0.1,1), // For parallax, [0.1..1]

r: r, c: `rgba(220,240,255,${rand(0.13,0.40).toFixed(2)})`

};

}

}

// Initial boot

function bootGame() {

canvas = document.getElementById('gameCanvas');

ctx = canvas.getContext('2d', {alpha:false, antialias:true});

resizeCanvas();

disableDefaultGestures();

requestDevicePermissionIfNeeded();

// responsive resize

window.addEventListener('resize', resizeCanvas);

permOverlay.style.display='none';

calibOverlay.style.display='none';

gameOverOverlay.style.display='none';

}

// On load

window.onload = bootGame;

// ========== CORE GAME LOOP ==========

function gameLoop(nowMS) {

if(!ctx) { requestAnimationFrame(gameLoop); return; }

let now = nowMS*0.001;

if(!tLast) tLast = now-0.016;

let dt = Math.min(0.048, now-tLast);

tLast = now;

if(!playing) { renderUI(); requestAnimationFrame(gameLoop); return; }

// --- Movement/Controls ---

if(initialSet) {

// Map (device) to (camera) angles

// Smoothed update (aimFilter), to avoid jitter

let rawPitch = ((lastDeviceBeta||0)-initialPitch)*CFG.sensitivity*Math.PI/180;

let rawYaw = ((lastDeviceGamma||0)-initialYaw)*CFG.sensitivity*Math.PI/180;

// Clamp to avoid excessive wander

rawPitch = clamp(rawPitch, -1.2, 1.2);

rawYaw = clamp(rawYaw, -1.5, 1.5);

targetPitch = rawPitch;

targetYaw = rawYaw;

camPitch = lerp(camPitch, targetPitch, CFG.aimFilter);

camYaw = lerp(camYaw, targetYaw, CFG.aimFilter);

// Recoil "wiggle" (cosmetic)

if(crosshairJitter.frames>0) {

aimRecoil = lerp(aimRecoil, 0, 0.25);

crosshairJitter.x = Math.sin(Math.PI*crosshairJitter.frames/8)*3 * aimRecoil;

crosshairJitter.y = Math.cos(Math.PI*crosshairJitter.frames/10)*3 * aimRecoil;

--crosshairJitter.frames;

}

}

// --- Update entities ---

updateAsteroids(dt);

updateLasers(dt);

updateExplosions(dt);

// --- Collisions ---

checkLaserAsteroidHits();

checkPlayerAsteroidCollisions();

// --- Shooting ---

if(shooting && (now > lastLaserTime+CFG.laserCooldown)) {

fireLaser();

lastLaserTime = now;

}

// --- Difficulty (time) ---

asteroidLevel = clamp(1+score/24, 1, 5);

asteroidTimer += dt*asteroidLevel;

while(asteroids.length<Math.floor(CFG.maxAsteroids+score/40) && asteroidTimer>1.0/CFG.asteroidFreq) {

spawnAsteroid();

asteroidTimer-=1.0/CFG.asteroidFreq;

}

// --- Render ---

renderScene();

// --- GameOver check ---

if(health<=0 && !gameOver) {

health=0; playing=false; gameOver=true;

finalScore.textContent = `SCORE: ${score}`;

setTimeout(()=>gameOverOverlay.style.display='flex',340);

playCrashSFX();

}

requestAnimationFrame(gameLoop);

}

// ===================== ENTITY MANAGEMENT =========================

function spawnAsteroid() {

let theta = rand(-1.1,1.1); // yaw, rad

let phi = rand(-0.48,0.48); // pitch, rad

let dist = rand(0.9,1.62)*1.85*minWH; // units, px (farZ)

// Map arc (theta/phi) to 3D dir, then to screen

let size = rand(CFG.astMinSize,CFG.astMaxSize)*

lerp(1,1.25,Math.random());

let color = CFG.asteroidColors[

(Math.floor(rand(0,CFG.asteroidColors.length))%CFG.asteroidColors.length)

];

let az = Math.cos(phi)*Math.cos(theta), ay = Math.sin(phi), ax = Math.cos(phi)*Math.sin(theta);

// Place at far-z, project so that on screen they're visible (avoid too central)

let pt = {x: az*dist*0.27 + rand(-20,20), y: ay*dist*0.27 + rand(-20,20)};

let z0 = dist;

asteroids.push({

x: pt.x, y: pt.y, z: z0,

vx: 0, vy: 0, vz: -CFG.asteroidSpeed*rand(0.93,1.13),

r: size, c: color, hit:false

});

}

function updateAsteroids(dt) {

for(let i=asteroids.length-1; i>=0; --i) {

let a = asteroids[i];

a.z += a.vz*dt*gameSpeed;

if(a.z<0.42*CFG.astMinSize) {

asteroids.splice(i,1);

continue;

}

}

}

function spawnLaser() {

// Laser fires forward in current cam orientation ("screen center" direction)

let d = directionForCamera();

lasers.push({

x:0, y:0, z:0,

dx:d.x, dy:d.y, dz:d.z,

r:CFG.laserRadius,

t:0, live:true

});

}

function fireLaser() {

if(!playing || !initialSet) return;

spawnLaser();

playLaserSFX();

aimRecoil = CFG.recoilKick;

crosshairJitter.frames = 12;

}

function updateLasers(dt) {

for(let i=lasers.length-1; i>=0; --i) {

let l = lasers[i];

l.x += l.dx*CFG.laserSpeed*dt;

l.y += l.dy*CFG.laserSpeed*dt;

l.z += l.dz*CFG.laserSpeed*dt;

l.t += dt;

if(l.z>2.2*minWH || l.z<0) // out of view

lasers.splice(i,1);

}

}

function spawnExplosion(ax,ay,az,radius,color) {

explosions.push({

x:ax, y:ay, z:az, r:radius, c:color,

t:0, maxT:CFG.explosionFrames

});

playExplosionSFX();

}

function updateExplosions(dt) {

for(let i=explosions.length-1; i>=0; --i) {

let e = explosions[i];

e.t += dt*CFG.explosionFrames*2.4;

if(e.t>e.maxT)

explosions.splice(i,1);

}

}

// --------- COLLISIONS ----------

function checkLaserAsteroidHits() {

for(let li=lasers.length-1; li>=0; --li) {

let l = lasers[li];

for(let ai=asteroids.length-1; ai>=0; --ai) {

let a = asteroids[ai];

if(a.hit) continue;

let dx = a.x-l.x, dy = a.y-l.y, dz = a.z-l.z;

let dist = Math.sqrt(dx*dx+dy*dy+dz*dz);

if(dist < a.r + l.r*1.4) {

// Hit

score += Math.round(5+a.r*0.5);

a.hit = true;

spawnExplosion(a.x,a.y,a.z, a.r*1, a.c);

asteroids.splice(ai,1);

lasers.splice(li,1);

break;

}

}

}

}

function checkPlayerAsteroidCollisions() {

// Player = at (0,0,0); asteroids approaching

for(let ai=asteroids.length-1; ai>=0; --ai) {

let a = asteroids[ai];

let dx = a.x, dy=a.y, dz=a.z;

let dist = Math.sqrt(dx*dx+dy*dy+dz*dz);

let nearZ = 1.3*CFG.astMinSize; // not at 0!

if((a.z<=nearZ) && dist < a.r*0.7+CFG.astMinSize*0.33) {

// Hit!

health -= CFG.damageOnHit;

spawnExplosion(a.x,a.y,a.z, a.r*1.34, a.c);

asteroids.splice(ai,1);

playDamageSFX();

break;

}

}

}

// -------- HELPER: CAMERA DIRECTION VECTOR (screen-centric) -------

function directionForCamera() {

// Map (yaw,pitch) to a unit vector (x,y,z) in camera space

return {

x: Math.sin(camYaw)*Math.cos(camPitch),

y: Math.sin(camPitch),

z: Math.cos(camYaw)*Math.cos(camPitch)

};

}

// ================== RENDERING ==========================

function renderScene() {

ctx.clearRect(0,0,W,H);

renderStarfield();

renderAsteroids();

renderLasers();

renderExplosions();

renderCockpitHUD();

}

function renderUI() {

renderScene();

if(!devicePermGranted || !initialSet || calibrating) {

// Overlay handled by HTML

}

// If not playing: Show pause/game over handled by overlays

}

function renderStarfield() {

// Simple parallax; stars "move" slightly by camera angle

let parX = camYaw * 0.22*cx, parY = camPitch*0.21*cy;

for(let i=0; i<stars.length; ++i) {

let s = stars[i];

let px = cx + s.x*s.z + parX*(1-s.z);

let py = cy + s.y*s.z + parY*(1-s.z);

ctx.beginPath();

ctx.arc(px,py,s.r,0,2*Math.PI);

ctx.fillStyle = s.c;

ctx.fill();

}

}

function renderAsteroids() {

// Map 3D asteroid pos -> view (screen) using basic perspective

for(let i=0; i<asteroids.length; ++i) {

let a = asteroids[i];

let pt = worldToScreen(a.x,a.y,a.z);

// Extra shading & depth

let size = a.r * perspectiveScale(a.z);

let grad = ctx.createRadialGradient(pt.x,pt.y,2,pt.x,pt.y,size*0.93);

grad.addColorStop(0.18,a.c);

grad.addColorStop(rand(0.22,0.45),'#fff5');

grad.addColorStop(0.7, shadeHex(a.c,-0.21));

grad.addColorStop(1.0, '#0b193b');

ctx.beginPath();

ctx.arc(pt.x, pt.y, size, 0, 2*Math.PI);

ctx.fillStyle = grad;

ctx.shadowColor=a.c; ctx.shadowBlur=10+size*0.5;

ctx.globalAlpha=a.hit?0.33:1;

ctx.fill();

ctx.shadowBlur=0; ctx.globalAlpha=1;

// "Facets" highlight for sci-fi

if(Math.random()<0.23) {

ctx.beginPath();

let ang = Math.random()*2*Math.PI;

ctx.ellipse(pt.x,pt.y, size*rand(0.19,0.37), size*rand(0.11,0.23), ang,0,2*Math.PI);

ctx.globalAlpha=0.22;

ctx.fillStyle='#eaffcc';

ctx.fill();

ctx.globalAlpha=1;

}

}

}

function renderLasers() {

for(let i=0;i<lasers.length;++i) {

let l=lasers[i];

let pt=worldToScreen(l.x,l.y,l.z);

let sz = l.r*perspectiveScale(l.z);

ctx.save();

ctx.beginPath();

ctx.arc(pt.x,pt.y, sz*1.6,0,2*Math.PI);

ctx.globalAlpha=0.81;

ctx.fillStyle='rgba(100,255,255,0.58)';

ctx.shadowColor='#0ff8';

ctx.shadowBlur=10;

ctx.fill();

ctx.restore();

// Core

ctx.beginPath();

ctx.arc(pt.x,pt.y, sz*0.88, 0, 2*Math.PI);

ctx.globalAlpha=1;

ctx.fillStyle='#eafdff';

ctx.fill();

ctx.globalAlpha=1;

}

}

function renderExplosions() {

for(let i=0;i<explosions.length;++i) {

let e=explosions[i];

let pt = worldToScreen(e.x,e.y,e.z);

let fr=e.t/e.maxT;

let sz = e.r*perspectiveScale(e.z)*(1.16+fr*0.41);

let grad = ctx.createRadialGradient(pt.x,pt.y,0.8,pt.x,pt.y,sz*1.09);

grad.addColorStop(0.0,'#fffcc0');

grad.addColorStop(0.2,shadeHex(e.c,0.15));

grad.addColorStop(0.5,shadeHex(e.c,-0.13));

grad.addColorStop(1.0,'rgba(10,20,38,0.01)');

ctx.globalAlpha = lerp(0.83, 0.1, fr*fr);

ctx.beginPath();

ctx.arc(pt.x,pt.y, sz, 0, 2*Math.PI);

ctx.fillStyle = grad; ctx.fill(); ctx.globalAlpha=1;

}

}

function renderCockpitHUD() {

let barW = Math.floor(minWH*0.36), barH = minWH*0.035;

// Cockpit glass

ctx.save();

ctx.beginPath();

let yCockpit = H-(CFG.cockpitH*H);

ctx.moveTo(cx-0.45*barW, H);

ctx.bezierCurveTo(cx-0.54*barW, H, cx-0.37*barW, yCockpit, cx, yCockpit-0.04*minWH);

ctx.bezierCurveTo(cx+0.37*barW, yCockpit, cx+0.54*barW, H, cx+0.45*barW, H);

ctx.closePath();

let grad = ctx.createLinearGradient(cx, yCockpit, cx,H);

grad.addColorStop(0.19,"#0b193b");

grad.addColorStop(0.5,"#255b8e99");

grad.addColorStop(0.85,"#77e0ffe3");

ctx.globalAlpha=0.54;

ctx.fillStyle=grad; ctx.fill(); ctx.globalAlpha=1;

ctx.restore();

// Score

ctx.font = `bold ${Math.floor(0.047*minWH)}px Orbitron, monospace, Arial`;

ctx.textAlign='left'; ctx.textBaseline='top';

ctx.fillStyle = '#66d9ff';

ctx.shadowColor="#43e7ff44"; ctx.shadowBlur=22;

ctx.fillText('SCORE '+score,0.078*W,0.033*minWH+5);

ctx.shadowBlur=0;

// Health bar

ctx.save();

ctx.lineJoin="round";

ctx.lineWidth=barH*0.88;

let grad2=ctx.createLinearGradient(cx-barW/2,0,cx+barW/2,0);

grad2.addColorStop(0.0,'#22e5ff');

grad2.addColorStop(0.52, health/CFG.playerMaxHealth>0.52 ? '#99faff': '#f3f36d');

grad2.addColorStop(1.0,(health/CFG.playerMaxHealth<0.46)? "#ff4a41":"#227ebb");

ctx.strokeStyle=grad2;

ctx.beginPath();

ctx.moveTo(cx-barW/2, 0.058*minWH+barH*1.6);

ctx.lineTo(cx-barW/2+barW*(health/CFG.playerMaxHealth), 0.058*minWH+barH*1.6);

ctx.shadowColor="#bbfff6"; ctx.shadowBlur=10;

ctx.stroke();

// Outline

ctx.globalAlpha=0.18; ctx.shadowBlur=0; ctx.strokeStyle='#fff8';

ctx.beginPath();

ctx.moveTo(cx-barW/2, 0.058*minWH+barH*1.6);

ctx.lineTo(cx+barW/2, 0.058*minWH+barH*1.6);

ctx.stroke(); ctx.globalAlpha=1; ctx.restore();

// Crosshair (centered)

renderCrosshair();

// HUD instructions (bottom left)

if(!gameOver&&!calibrating&&playing) {

ctx.font = `bold ${Math.floor(0.036*minWH)}px Orbitron, monospace, Arial`;

ctx.textAlign='left'; ctx.textBaseline='bottom';

ctx.fillStyle = '#99faff'; ctx.globalAlpha=0.46;

ctx.fillText('TAP BOTTOM to RECALIBRATE',0.072*W,H-0.04*H);

ctx.globalAlpha=1;

}

}

function renderCrosshair() {

// Crosshair always "forward", but center may wiggle slightly for feedback

ctx.save();

let s = Math.floor(CFG.crosshairSize*minWH);

let cxh = cx+(crosshairJitter.x||0), cyh=cy+(crosshairJitter.y||0);

ctx.strokeStyle='#aaffff';

ctx.lineWidth=2;

ctx.globalAlpha=0.81;

ctx.beginPath();

ctx.arc(cxh,cyh,s*0.6,0,2*Math.PI);

ctx.moveTo(cxh-s*1.07,cyh); ctx.lineTo(cxh-s*0.45,cyh);

ctx.moveTo(cxh+s*1.07,cyh); ctx.lineTo(cxh+s*0.45,cyh);

ctx.moveTo(cxh,cyh-s*1.07); ctx.lineTo(cxh,cyh-s*0.45);

ctx.moveTo(cxh,cyh+s*1.07); ctx.lineTo(cxh,cyh+s*0.45);

ctx.stroke();

ctx.globalAlpha=1;

ctx.lineWidth=1;

// Crosshair "dot"

ctx.beginPath();

ctx.arc(cxh,cyh,3,0,2*Math.PI);

ctx.fillStyle="#fff";

ctx.globalAlpha=0.37;

ctx.fill();

ctx.globalAlpha=1;

ctx.restore();

}

// Project (x,y,z) camera space to (screenX,screenY)

function worldToScreen(x,y,z) {

// Basic pinhole perspective based on field of view and canvas size

let fovRad = CFG.fov*0.5 * Math.PI/180;

let scale = cy / Math.tan(fovRad);

return {

x: cx + (x/z)*scale,

y: cy + (y/z)*scale

};

}

function perspectiveScale(z) {

let fovRad = CFG.fov*0.5 * Math.PI/180;

let scale = cy / Math.tan(fovRad);

return scale/z;

}

function shadeHex(hex, amount) { // "#rrggbb", brighten (amount>0)

hex=hex.replace("#",""); let n=parseInt(hex,16);

let r=((n>>16)&255)*(1+amount), g=((n>>8)&255)*(1+amount), b=(n&255)*(1+amount);

return `rgb(${clamp(r,0,255)|0},${clamp(g,0,255)|0},${clamp(b,0,255)|0})`;

}

// ====================== AUDIO ==========================

function playLaserSFX() {

let ctx = audioCtx();

let o = ctx.createOscillator(), g=ctx.createGain();

o.type='triangle'; o.frequency.value=520;

o.connect(g); g.connect(ctx.destination);

g.gain.value=0.22; g.gain.linearRampToValueAtTime(0.02,ctx.currentTime+0.18);

o.frequency.linearRampToValueAtTime(1000,ctx.currentTime+0.08);

o.frequency.linearRampToValueAtTime(310,ctx.currentTime+0.18);

o.start(); o.stop(ctx.currentTime+0.19);

}

function playExplosionSFX() {

let ctx = audioCtx();

let o = ctx.createOscillator(), g=ctx.createGain();

o.type='sawtooth'; o.frequency.value=120;

let f = ctx.createBiquadFilter();

f.type='lowpass'; f.frequency.value=600;

o.connect(f); f.connect(g); g.connect(ctx.destination);

g.gain.value=0.12; g.gain.linearRampToValueAtTime(0.03,ctx.currentTime+0.21);

o.frequency.linearRampToValueAtTime(40,ctx.currentTime+0.21);

o.start(); o.stop(ctx.currentTime+0.23);

}

function playDamageSFX() { // Player hit

let ctx = audioCtx();

let o = ctx.createOscillator(), g=ctx.createGain();

o.type='square'; o.frequency.value=380;

o.connect(g); g.connect(ctx.destination);

g.gain.value=0.11; g.gain.linearRampToValueAtTime(0.01,ctx.currentTime+0.21);

o.frequency.linearRampToValueAtTime(110,ctx.currentTime+0.14);

o.start(); o.stop(ctx.currentTime+0.2);

}

function playCrashSFX() {

let ctx = audioCtx();

let o = ctx.createOscillator(), g=ctx.createGain(), b=ctx.createBiquadFilter();

o.type='triangle'; o.frequency.value=83;

o.connect(b); b.type='lowpass'; b.frequency.value=340;

b.connect(g); g.connect(ctx.destination);

g.gain.value=0.18; g.gain.linearRampToValueAtTime(0.01,ctx.currentTime+0.39);

o.frequency.linearRampToValueAtTime(19,ctx.currentTime+0.38);

o.start(); o.stop(ctx.currentTime+0.39);

}

function audioCtx() {

if (!sfxCtx) {

window.AudioContext = window.AudioContext||window.webkitAudioContext;

sfxCtx = new AudioContext();

}

if(sfxCtx.state==='suspended') sfxCtx.resume();

return sfxCtx;

}

// ================================

// BOOT/READY STATE CONTROL

// ================================

function mainReadyInit() {

resetGame(true);

// Main loop start

requestAnimationFrame(gameLoop);

}

if (document.readyState === 'complete' || document.readyState === 'interactive')

setTimeout(mainReadyInit, 1);

else window.addEventListener('load', mainReadyInit);

</script>

</body>

</html>

