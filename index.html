<!DOCTYPE html>

<html lang="en">

<head>

<meta charset="utf-8"/>

<title>Space Shooter 3D: Immersive & Calibrated</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>

<meta name="apple-mobile-web-app-capable" content="yes"/>

<style>

html, body {

height: 100%;

margin: 0; padding: 0;

background: #10131e;

overflow: hidden;

touch-action: none;

user-select: none;

-webkit-user-select: none;

font-family: 'Orbitron', Arial, sans-serif;

}

#gameCanvas {

position: absolute;

width: 100vw; height: 100vh;

left: 0; top: 0; display: block;

z-index: 1;

background: #10131e;

touch-action: none;

}

#shootBtn {

position: absolute;

right: 8vw; bottom: 7vw;

width: 20vw; height: 20vw;

max-width: 100px; max-height: 100px;

min-width: 58px; min-height: 58px;

border-radius: 50%;

background: linear-gradient(145deg, #39eefdcc 60%, #2e78e6cc 100%);

border: 3px solid #36defe;

color: #fff;

font-size: 2.5rem;

font-family: inherit;

font-weight: bold;

box-shadow: 0 0 15px #00c4ef66;

z-index: 20;

display: flex; align-items: center; justify-content: center;

transition: background 0.13s;

cursor: pointer;

opacity: 0.96;

backdrop-filter: blur(2px);

}

#shootBtn:active {

background: linear-gradient(145deg, #82faff 60%, #2741efff 100%);

border-color: #66f3ff;

}

#scoreHud {

position: absolute; left: 3vw; top: 2vw;

z-index: 10;

background: #06131acc;

color: #e3fcff;

padding: 0.33em 1.2em 0.33em 1.25em;

border-radius: 13px;

font-size: 1.39rem;

box-shadow: 0 1.5px 8px #00e3ff32 inset;

pointer-events: none;

border: 1.5px solid #60fbff33;

font-weight: 600;

letter-spacing: 0.13em;

backdrop-filter: blur(4px);

}

#healthBar {

margin-top: .51em;

width: 100px;

height: 14px;

background: #164d5e88;

border-radius: 4px;

overflow: hidden;

border: 1.3px solid #40ffe973;

display: block;

}

#healthBar > div {

background: linear-gradient(90deg, #69ffb5 0%, #51e1fd 90%);

height: 100%;

border-radius: 3px;

box-shadow: 0 1.5px 12px #69ffb691;

transition: width 0.2s;

}

#centerCrosshair {

position: absolute;

left: 50%; top: 50%;

pointer-events: none;

z-index: 15;

transition: transform 0.09s cubic-bezier(.4,.5,.4,1.28);

}

#centerCrosshair svg {

display: block;

width: 54px; height: 54px;

opacity: 0.93;

}

#gameOverHud {

position: absolute; left: 50%; top: 44%; transform: translate(-50%,-55%);

z-index: 100;

min-width: 225px;

padding: 25px 34px 32px 34px;

background: rgba(9,21,36,.97);

color: #d2fffd;

font-size: 2.2rem;

border-radius: 17px;

box-shadow: 0 2px 30px #00eaff66, 0 1px 6px #0cecff;

text-align: center;

display: none;

user-select: none;

border: 2px solid #45e2fa52;

backdrop-filter: blur(3.5px);

}

#restartBtn {

margin-top: 1.2em;

font-size: 1.25rem;

font-weight: bold;

padding: 0.68em 1.8em;

border-radius: 13px;

border: none;

background: linear-gradient(100deg, #27e3ff 8%, #2773ef 87%);

color: #fff; letter-spacing: 0.07em;

box-shadow: 0 0 9px #13ecffb4;

cursor: pointer;

outline: none;

font-family: inherit;

transition: background 0.13s;

}

#restartBtn:active { background: #1599cc; }

#permissionRequest {

position: absolute; left: 0; top: 0; width: 100vw; height: 100vh;

background: #091016ef;

color: #fff;

display: flex;

align-items: center; justify-content: center;

font-size: 1.25rem;

flex-direction: column;

z-index: 999;

backdrop-filter: blur(2px);

user-select: none;

text-align: center;

}

#permissionBtn {

margin-top: 2em;

font-size: 1.24rem;

padding: 0.85em 2.24em;

background: #1de7ff;

color: #003242;

border: none;

border-radius: 11px;

font-weight: bold;

box-shadow: 0 0 13px #41e7ffb2, 0 5px 24px #2fdaff52;

letter-spacing: 0.04em;

cursor: pointer;

}

::-webkit-scrollbar {display:none;}

</style>

</head>

<body>

<canvas id="gameCanvas"></canvas>

<div id="scoreHud">

<span id="scoreField">SCORE: 0</span>

<div id="healthBar"><div></div></div>

</div>

<div id="centerCrosshair">

<svg viewBox="0 0 52 52">

<circle cx="26" cy="26" r="15" fill="none" stroke="#30edff" stroke-width="2.1"/>

<circle cx="26" cy="26" r="3.7" fill="#31cdff" fill-opacity="0.18" stroke="#11ffd1" stroke-width="1.3"/>

<path d="M22 26h-7" stroke="#bafcfb" stroke-width="1.35" stroke-linecap="round"/>

<path d="M36 26h7" stroke="#bafcfb" stroke-width="1.35" stroke-linecap="round"/>

<path d="M26 22v-7" stroke="#98f7f7" stroke-width="1.35" stroke-linecap="round"/>

<path d="M26 36v7" stroke="#98f7f7" stroke-width="1.35" stroke-linecap="round"/>

</svg>

</div>

<button id="shootBtn">ðŸ’¥</button>

<div id="permissionRequest" style="display:none;">

<div style="font-size:1.4em;font-weight:bold;">ðŸš€ Allow Motion Sensor Access</div>

<div style="margin-top:1.1em;max-width:88vw;font-size:1.17em;">

This game uses the accelerometer to steer and aim.<br>TAP ALLOW to enable controls and calibrate.

</div>

<button id="permissionBtn">ALLOW</button>

</div>

<div id="gameOverHud">

<div id="gameOverText">CRASHED!</div>

<div id="finalScore" style="margin-top:.5em;color:#7fceff;font-size:1.1em;"></div>

<button id="restartBtn">RESTART</button>

</div>

<script>

/* ------------------ GAME STATE & CONSTANTS ------------------ */

const width = window.innerWidth, height = window.innerHeight;

const FOV = 75, Z_NEAR = 0.2, Z_FAR = 120;

const canvas = document.getElementById('gameCanvas');

const ctx = canvas.getContext('2d');

canvas.width = width; canvas.height = height;

function resizeCanvas() {

canvas.width = window.innerWidth;

canvas.height = window.innerHeight;

}

window.addEventListener('resize', resizeCanvas);

/* --- UI Elements --- */

const shootBtn = document.getElementById('shootBtn');

const scoreField = document.getElementById('scoreField');

const healthBarInner = document.querySelector('#healthBar > div');

const permissionRequest = document.getElementById('permissionRequest');

const permissionBtn = document.getElementById('permissionBtn');

const gameOverHud = document.getElementById('gameOverHud');

const gameOverText = document.getElementById('gameOverText');

const finalScore = document.getElementById('finalScore');

const restartBtn = document.getElementById('restartBtn');

const crosshairDiv = document.getElementById('centerCrosshair');

/* ------------------ PLAYER/SHIP STATE ---------------------- */

const player = {

x: 0, y: 0, z: 4,

rotX: 0, rotY: 0, // In radians; relative to calibration baseline!

aimX: 0, aimY: 0, // Smoothed for crosshair

v: 1.35,

inertia: 0.13,

aimSmooth: 0.16,

maxTiltAngle: 1.1, // Limit

health: 1.0,

lastLaser: 0,

score: 0,

dead: false,

invuln: 0,

// For calibration

baselineBeta: null,

baselineGamma: null

};

/*

Accelerometer Calibration logic:

- At game start (or calibrate), baselineBeta/Gamma are set to current orientation.

- All orientation readings during play are expressed as

(current_beta - baselineBeta) and (current_gamma - baselineGamma),

giving "center-forward" matching initial hold.

- All aim/camera rotation math uses these diffs (in degrees to radians, clamped).

- The crosshair is always at the projected center of the view/camera.

*/

/* ----------------- OBJECTS --------------------- */

let asteroids = [];

let debris = [];

let enemies = [];

let lasers = [];

let explosions = [];

let crashAnim = 0;

let starfield = [];

const STAR_COUNT = Math.min(190, Math.floor(width*height/750));

function genStarfield() {

// More subtle depth, varied star color

starfield = [];

for (let i=0; i<STAR_COUNT; ++i) {

let colorSet = [

"#f7fafd", // white

"#ccdbe9", // blue-ish

"#8ee3e9", // cyan

"#ffe9da", // warm

"#b4b5c8", // gray faint

"#f9bcb4" // pale red

];

starfield.push({

x: (Math.random()*2-1)*13,

y: (Math.random()*2-1)*10,

z: Math.random()*70+10,

color: colorSet[Math.floor(Math.random()*colorSet.length)],

twinkle: Math.random()<0.27

});

}

}

genStarfield();

/* --- Difficulty - up as score rises --- */

let asteroidSpeed = 8.2, asteroidInterval = 900, debrisInterval = 1200, enemyInterval = 2700;

let lastAsteroid = 0, lastDebris = 0, lastEnemy = 0;

/* ---------------- DeviceMotion CALIBRATION HANDLING ----------------- */

let tiltActive = false;

let initialised = false; // Set to true after first calibration

let rawBeta = 0, rawGamma = 0; // Most recent values

function calibrateOrientation() {

// Called at game start or tap to set forward "zero"

player.baselineBeta = rawBeta || 0;

player.baselineGamma = rawGamma || 0;

initialised = true;

}

function handleTilt(beta, gamma) {

// Both are degrees; use diff from baseline (see calibrateOrientation notes above)

if (!initialised) return;

let dG = gamma - player.baselineGamma;

let dB = beta - player.baselineBeta;

// Clamp for sanity

dG = Math.max(-player.maxTiltAngle*57.3, Math.min(player.maxTiltAngle*57.3, dG));

dB = Math.max(-player.maxTiltAngle*57.3, Math.min(player.maxTiltAngle*57.3, dB));

// Smooth aim for visual crosshair - more responsive than main ship to track view

player.aimY += ((dG*Math.PI/180)-player.aimY) * 0.37;

player.aimX += ((dB*Math.PI/180)-player.aimX) * 0.37;

// Camera

player.rotY += (((dG*Math.PI/180) - player.rotY) * player.aimSmooth);

player.rotX += (((dB*Math.PI/180) - player.rotX) * player.aimSmooth);

}

/* --- Setup DeviceMotion --- */

function setupMotion() {

tiltActive = true;

window.addEventListener('deviceorientation', function(e){

rawBeta = e.beta; rawGamma = e.gamma;

handleTilt(rawBeta, rawGamma);

}, true);

}

/* --- Permission for iPhone Safari --- */

function requestMotionPermissionIfNeeded(){

let needPerm = window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission==="function";

if(needPerm){

permissionRequest.style.display="flex";

permissionBtn.onclick=function(){

DeviceMotionEvent.requestPermission().then(function(state){

if(state==='granted'){

permissionRequest.style.display="none";

setupMotion();

}

});

}

} else {

permissionRequest.style.display="none";

setupMotion();

}

}

requestMotionPermissionIfNeeded();

// Tap-hold anywhere to recalibrate orientation

window.addEventListener('touchend',function(e){

calibrateOrientation();

showCenterMsg("Calibrated!");

setTimeout(hideCenterMsg,900);

},{passive:true});

// On initial game load, calibrate after 0.3s (ensures phone is steady at entry)

setTimeout(calibrateOrientation, 350);

/* ------------ SHOOTING (No Aim Reset) ------------ */

// Laser fires in the current camera direction (rotX, rotY at click)

function getAimDir() {

const sinX = Math.sin(player.rotX), cosX = Math.cos(player.rotX);

const sinY = Math.sin(player.rotY), cosY = Math.cos(player.rotY);

const dx = sinY * cosX;

const dy = sinX;

const dz = cosY * cosX;

const len = Math.sqrt(dx*dx+dy*dy+dz*dz);

return {dx:dx/len, dy:dy/len, dz:dz/len};

}

function fireLaser(evt) {

if (player.dead) return;

if (evt && evt.preventDefault) evt.preventDefault();

const now = performance.now()/1000;

if (now - player.lastLaser < 0.16) return;

player.lastLaser = now;

// Use *actual* current orientation, do NOT reset camera angles

const {dx,dy,dz} = getAimDir();

lasers.push({

x: player.x,

y: player.y,

z: player.z+0.7,

dx, dy, dz,

t: now

});

playLaserSound();

}

shootBtn.addEventListener('touchstart', fireLaser, {passive:false});

shootBtn.addEventListener('mousedown', fireLaser);

/* ---------- SFX ----------- */

let audioCtx = null;

function playLaserSound(){

try{

window.AudioContext = window.AudioContext||window.webkitAudioContext;

audioCtx = audioCtx || new AudioContext();

const o = audioCtx.createOscillator();

const g = audioCtx.createGain();

o.type = 'triangle';

o.frequency.setValueAtTime(1100,audioCtx.currentTime);

o.frequency.linearRampToValueAtTime(1400,audioCtx.currentTime+0.07);

o.frequency.linearRampToValueAtTime(550,audioCtx.currentTime+0.15);

g.gain.setValueAtTime(.20,audioCtx.currentTime);

g.gain.linearRampToValueAtTime(0.01,audioCtx.currentTime+0.17);

o.connect(g); g.connect(audioCtx.destination);

o.start(); o.stop(audioCtx.currentTime+0.18);

}catch(e){}

}

function playExplosionSound(){

try{

audioCtx = audioCtx || (window.AudioContext?new AudioContext():null);

if (!audioCtx) return;

const o = audioCtx.createOscillator();

const g = audioCtx.createGain();

o.type = 'sawtooth'; g.gain.value=0.3;

o.frequency.setValueAtTime(190,audioCtx.currentTime);

o.frequency.linearRampToValueAtTime(44,audioCtx.currentTime+0.29);

g.gain.setValueAtTime(.25, audioCtx.currentTime);

g.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime+0.31);

o.connect(g); g.connect(audioCtx.destination);

o.start(); o.stop(audioCtx.currentTime+0.33);

}catch(e){}

}

function playCrashSound(){

try {

audioCtx = audioCtx || (window.AudioContext?new AudioContext():null);

if (!audioCtx) return;

const o = audioCtx.createOscillator();

const g = audioCtx.createGain();

o.type = "square"; g.gain.value=0.4;

o.frequency.setValueAtTime(310,audioCtx.currentTime);

o.frequency.linearRampToValueAtTime(62,audioCtx.currentTime+0.21);

g.gain.setValueAtTime(.33, audioCtx.currentTime);

g.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime+0.24);

o.connect(g); g.connect(audioCtx.destination);

o.start(); o.stop(audioCtx.currentTime+0.26);

}catch(e){}

}

/* ------------- GAME OBJECTS SPAWN & PHYSICS ---------------- */

function spawnAsteroid() {

/* Asteroid: large, colored, varied! */

// Size increased for visibility (see also style variants)

const styles = [

// grays, reds, icy blue, brown

{tone:0.74, edge:"#b2b2c2", fill:"#9994a6"},

{tone:0.51, edge:"#efe2e2", fill:"#e48577"},

{tone:0.61, edge:"#b9f3ff", fill:"#90daef"},

{tone:0.62, edge:"#f4d7a7", fill:"#ad7c5d"},

{tone:0.82, edge:"#efc6ff", fill:"#eebaee"},

{tone:0.41, edge:"#888", fill:"#65666b"}

];

const style = styles[Math.floor(Math.random()*styles.length)];

const radius = 3.8 + Math.random()*2.1; // LARGE!

const theta = (Math.random()-0.5) * Math.PI*0.7;

const phi = (Math.random()-0.5) * Math.PI/4;

let dist = 40 + Math.random()*30;

let fx = Math.sin(theta) * dist;

let fy = Math.sin(phi) * dist;

let fz = Math.cos(theta) * dist;

let vx = (Math.random()-0.5)*0.25;

let vy = (Math.random()-0.5)*0.22;

let vz = -(asteroidSpeed*0.95 + Math.random()*asteroidSpeed*0.18);

asteroids.push({

x: player.x + fx, y: player.y + fy, z: player.z + fz,

radius: radius,

rot: [Math.random()*Math.PI*2, Math.random()*Math.PI*2],

rotSpeed: [(Math.random()-0.5)*1.1, (Math.random()-0.5)*.7],

fill: style.fill,

edge: style.edge,

colorTone: style.tone,

vx, vy, vz

});

}

function spawnDebris() {

// Smaller fragments, blue/metallic/glassy variants

const debrisColors=['#7cb2ae','#b0dbee','#d2dbff','#8e9fb6','#c6eaff','#eee9ff'];

const size = 1.25+Math.random()*1.12;

const angle = (Math.random()-0.5)* Math.PI;

let dist = 31 + Math.random()*45;

let fx = Math.sin(angle)*dist;

let fy = (Math.random()-0.5)*10.2;

let fz = Math.cos(angle)*dist;

debris.push({

x:player.x+fx, y:player.y+fy, z:player.z+fz,

radius:size,

rot: [Math.random()*Math.PI*2],

rotSpeed: [(Math.random()-0.5)*2.4],

color: debrisColors[Math.floor(Math.random()*debrisColors.length)],

vx:(Math.random()-0.5)*0.17,vy:(Math.random()-0.5)*0.17,

vz:-(asteroidSpeed*0.69 + Math.random()*asteroidSpeed*0.31)

});

}

function spawnEnemy(){

// Triangular, white/blue glow

const dist = 55 + Math.random()*25;

const h = (Math.random()-0.5) * Math.PI*0.83;

let fx = Math.sin(h)*dist;

let fy = (Math.random()-0.5) * 6.5;

let fz = Math.cos(h)*dist;

enemies.push({

x:player.x+fx, y:player.y+fy, z:player.z+fz,

radius: 2.1+Math.random()*1.1,

rot: (Math.random()-0.5)*Math.PI,

speed: -(asteroidSpeed*0.91 + Math.random()*asteroidSpeed*0.18),

health:2

});

}

/* ------------- 3D PROJECTION ------------------- */

function project3D(wx,wy,wz){

// "Camera" looks from player pos, with rotX/pitch and rotY/yaw.

let dx = wx-player.x, dy = wy-player.y, dz = wz-player.z;

let cy = Math.cos(-player.rotY), sy = Math.sin(-player.rotY);

let x = cy*dx - sy*dz;

let z = sy*dx + cy*dz;

let cx = Math.cos(-player.rotX), sx = Math.sin(-player.rotX);

let y = cx*dy - sx*z;

z = sx*dy + cx*z;

if(z < Z_NEAR) return null;

const f = 0.57*height / Math.tan(FOV * Math.PI/360);

let px = width/2 + x/z * f;

let py = height/2 + y/z * f*0.98;

return {x:px, y:py, z:z};

}

/* ------------- COLLISIONS ---------------------- */

function segmentSphereHit(l, segLen, obj, rad){

let p1=[l.x,l.y,l.z], p2=[l.x+l.dx*segLen,l.y+l.dy*segLen,l.z+l.dz*segLen];

let c=[obj.x,obj.y,obj.z];

let ab=[p2[0]-p1[0],p2[1]-p1[1],p2[2]-p1[2]];

let ac=[c[0]-p1[0],c[1]-p1[1],c[2]-p1[2]];

let ab2 = ab[0]*ab[0]+ab[1]*ab[1]+ab[2]*ab[2];

let t = ab2!==0?(

(ac[0]*ab[0]+ac[1]*ab[1]+ac[2]*ab[2])/ab2

):0;

t = Math.max(0,Math.min(1,t));

let cx=p1[0]+ab[0]*t, cy=p1[1]+ab[1]*t, cz=p1[2]+ab[2]*t;

let dd=(cx-c[0])**2+(cy-c[1])**2+(cz-c[2])**2;

return dd < rad*rad;

}

function sphereDistance(a,ra,b,rb){

let dx = a.x-b.x, dy=a.y-b.y, dz=a.z-b.z;

return Math.sqrt(dx*dx+dy*dy+dz*dz) - (ra+rb);

}

/* ------------ HUD, COCKPIT, RENDERING ------------ */

function renderStarfield(){

for(let s of starfield){

let z = s.z;

let offX = s.x + player.rotY*28;

let offY = s.y + player.rotX*29;

let pr = project3D(player.x+offX, player.y+offY, player.z+z);

if(!pr) continue;

let base = 1.2 + 3.9/(pr.z+2); // slightly more visible

ctx.globalAlpha = Math.max(0.14, 0.43/(pr.z*0.17));

ctx.fillStyle = s.color;

let tw = s.twinkle? (0.7 + Math.abs(Math.sin(Date.now()*0.0012+z))*0.5) : 1;

ctx.beginPath();

ctx.arc(pr.x, pr.y, base*tw, 0, 2*Math.PI);

ctx.fill();

}

ctx.globalAlpha=1;

}

function renderAsteroids(){

for(let a of asteroids){

let pr = project3D(a.x,a.y,a.z); if(!pr) continue;

let rad = a.radius * (height/15.5)/pr.z;

ctx.save(); ctx.translate(pr.x,pr.y);

// Shadowed edge

let shade = ctx.createRadialGradient(0,0,rad*0.55, 0,0,rad*1.2);

shade.addColorStop(0,a.fill);

shade.addColorStop(0.75,a.edge);

shade.addColorStop(1,"#111");

ctx.beginPath();

ctx.arc(0,0,rad,0,2*Math.PI);

ctx.fillStyle=shade;

ctx.shadowColor="#222a";

ctx.shadowBlur=rad*0.6;

ctx.fill();

// Simulated craters/highlights

ctx.globalAlpha=0.23;

for(let i=0;i<6;i++){

let ang = i*2*Math.PI/6 + a.rot[0];

ctx.beginPath();

ctx.arc(Math.cos(ang)*rad*0.5, Math.sin(ang)*rad*0.58, rad*0.35, 0, 2*Math.PI);

ctx.fillStyle = "#181816";

ctx.fill();

}

ctx.globalAlpha=1;

ctx.restore();

a.rot[0]+=a.rotSpeed[0]*0.021;

a.rot[1]+=a.rotSpeed[1]*0.019;

}

}

function renderDebris(){

for(let d of debris){

let pr = project3D(d.x,d.y,d.z); if(!pr) continue;

let rad = d.radius * (height/30)/pr.z;

ctx.save(); ctx.translate(pr.x,pr.y); ctx.rotate(d.rot[0]);

ctx.fillStyle = d.color; ctx.globalAlpha=0.83;

// "shard" shape

ctx.beginPath();

ctx.moveTo(0,-rad*1.05); ctx.lineTo(rad*0.57,rad*0.8); ctx.lineTo(-rad*0.5,rad*0.53); ctx.closePath();

ctx.fill(); ctx.globalAlpha=1; ctx.restore();

d.rot[0]+=d.rotSpeed[0]*0.035;

}

}

function renderEnemies(){

for(let e of enemies){

let pr = project3D(e.x,e.y,e.z); if(!pr) continue;

let rad = e.radius * (height/15)/pr.z;

ctx.save();

ctx.translate(pr.x,pr.y); ctx.rotate(e.rot);

ctx.beginPath();

ctx.moveTo(0,-rad*1.09);

ctx.lineTo(rad*0.9,rad*1.07);

ctx.lineTo(-rad*0.9,rad*1.07);

ctx.closePath();

ctx.fillStyle = "#6cfbfa";

ctx.shadowColor = "#3ee6f6";

ctx.shadowBlur = 8;

ctx.globalAlpha = 0.83;

ctx.fill();

ctx.beginPath(); ctx.arc(0,0, rad*0.44,0,2*Math.PI);

ctx.globalAlpha=0.34; ctx.fillStyle="#fff";

ctx.fill();

ctx.restore();

}

}

function renderLasers(){

for(let l of lasers){

const len = 3.5;

let prj1 = project3D(l.x, l.y, l.z);

let prj2 = project3D(l.x+l.dx*len, l.y+l.dy*len, l.z+l.dz*len);

if(!prj1||!prj2) continue;

ctx.save();

let grad = ctx.createLinearGradient(prj1.x,prj1.y,prj2.x,prj2.y);

grad.addColorStop(0,"#fff");

grad.addColorStop(0.36,"#12f2ff");

grad.addColorStop(1,"#0af7e7");

ctx.strokeStyle=grad;

ctx.lineWidth = 3.4 + 5.2/(0.53+prj1.z);

ctx.shadowColor="#21eaff";

ctx.shadowBlur=12;

ctx.beginPath();

ctx.moveTo(prj1.x,prj1.y);

ctx.lineTo(prj2.x,prj2.y);

ctx.stroke();

ctx.globalAlpha=0.18;

ctx.beginPath();

ctx.arc(prj1.x,prj1.y, ctx.lineWidth*1.7, 0, 2*Math.PI);

ctx.fillStyle="#aeecff"; ctx.fill();

ctx.globalAlpha=1; ctx.restore();

}

}

function renderExplosions(){

for(let e of explosions){

let t = Math.min(1, e.age/0.41);

let pr = project3D(e.x, e.y, e.z); if(!pr) continue;

let R = e.r / (1+t*1.25) * (height/24)/pr.z;

ctx.save();

let grd = ctx.createRadialGradient(pr.x,pr.y,0,pr.x,pr.y,R);

grd.addColorStop(0,"#fffbe6");

grd.addColorStop(0.28,"#ffe48e");

grd.addColorStop(0.68,"#f98e44");

grd.addColorStop(1,"rgba(220,80,40,0)");

ctx.globalAlpha=1-t;

ctx.beginPath();

ctx.arc(pr.x,pr.y,R,0,2*Math.PI);

ctx.fillStyle=grd; ctx.fill();

ctx.restore();

}

}

function renderCockpit(){

ctx.save();

const w = canvas.width, h = canvas.height;

ctx.globalAlpha = 0.8;

ctx.strokeStyle = "#14f8ff";

ctx.lineWidth = Math.max(2, w*0.012);

ctx.beginPath();

ctx.ellipse(w/2, h*0.57, w*0.39, h*0.32, 0, 0, Math.PI, true);

ctx.stroke();

ctx.globalAlpha = .14;

ctx.beginPath();

ctx.ellipse(w/2, h*0.7, w*0.25, h*0.13, 0, 0, 2*Math.PI);

ctx.fillStyle = "#cafdff";

ctx.fill();

// Dashboard

let dashH = h*0.155;

ctx.globalAlpha = .9;

let grd = ctx.createLinearGradient(0,h-dashH,0,h);

grd.addColorStop(0,"rgba(19,43,59,0.96)");grd.addColorStop(0.6,"#213e4e");

grd.addColorStop(1,"#142430");

ctx.fillStyle=grd;

ctx.beginPath();

ctx.moveTo(w*0.13,h-dashH*0.13);

ctx.lineTo(w*0.17,h-dashH*0.58);

ctx.bezierCurveTo(w*0.3,h-dashH*0.97, w*0.7,h-dashH*0.97, w*0.83,h-dashH*0.58);

ctx.lineTo(w*0.87,h-dashH*0.13);

ctx.lineTo(w*0.13,h-dashH*0.13);

ctx.closePath(); ctx.fill();

ctx.restore();

}

/* ------------ CROSSHAIR TRACKING ------------ */

// The crosshair is always at center, but for added effect and "tracking":

// We slightly offset the crosshair SVG position based on the ship's current view orientation.

// This keeps visual alignment with aiming and makes the crosshair "move" with view, without jitter.

/*

The visible center-crosshair is a DOM element (centerCrosshair).

We center it, but in JS, on every frame, we slightly shift its CSS translate

in X/Y according to player.aimY/player.aimX (in radians)

*/

function updateCrosshairPosition() {

// max shift for visual feedback (not raw aim!)

let maxPx = Math.min(width, height) * 0.22;

let px = player.aimY * maxPx;

let py = player.aimX * maxPx;

crosshairDiv.style.transform =

`translate(-50%, -50%) translate(${px}px,${py}px)`;

}

/* --- Center screen HUD message for calibration, etc. --- */

let centerMsgTimeout = null;

function showCenterMsg(msg) {

crosshairDiv.innerHTML = `<svg viewBox="0 0 52 52">

<circle cx="26" cy="26" r="15" fill="#0ad9fa44" stroke="#20edff" stroke-width="2.3"/>

<text x="26" y="29" fill="#e0f7fa" text-anchor="middle" font-size="9" font-family="sans-serif" font-weight="bold">${msg}</text>

<circle cx="26" cy="26" r="3.9" fill="#53cafd" />

</svg>`;

if (centerMsgTimeout) clearTimeout(centerMsgTimeout);

}

function hideCenterMsg() {

crosshairDiv.innerHTML = `

<svg viewBox="0 0 52 52">

<circle cx="26" cy="26" r="15" fill="none" stroke="#30edff" stroke-width="2.1"/>

<circle cx="26" cy="26" r="3.7" fill="#31cdff" fill-opacity="0.18" stroke="#11ffd1" stroke-width="1.3"/>

<path d="M22 26h-7" stroke="#bafcfb" stroke-width="1.35" stroke-linecap="round"/>

<path d="M36 26h7" stroke="#bafcfb" stroke-width="1.35" stroke-linecap="round"/>

<path d="M26 22v-7" stroke="#98f7f7" stroke-width="1.35" stroke-linecap="round"/>

<path d="M26 36v7" stroke="#98f7f7" stroke-width="1.35" stroke-linecap="round"/>

</svg>

`;

centerMsgTimeout = null;

}

/* -------------- MAIN GAME LOOP -------------- */

let lastFrame = null;

function resetGame(){

player.x = 0; player.y = 0; player.z = 4; player.rotX = 0; player.rotY = 0;

player.aimX=0; player.aimY=0;

player.health = 1.0; player.dead=false; player.score=0;

player.invuln=0;

asteroids = []; debris = []; enemies = []; lasers = []; explosions = [];

lastAsteroid=0; lastDebris=0; lastEnemy=0; asteroidSpeed = 8.2; asteroidInterval=900;

debrisInterval=1200; enemyInterval=2700; crashAnim = 0; genStarfield();

gameOverHud.style.display = 'none';

hideCenterMsg();

lastFrame=null; requestAnimationFrame(gameLoop);

}

// GAME OVER/RESTART

restartBtn.onclick = resetGame;

function endGame(reason) {

player.dead = true;

setTimeout(()=>{

gameOverHud.style.display = 'block';

gameOverText.textContent = reason||'Crashed!';

finalScore.innerHTML = `FINAL SCORE<br /><span style="color:#beeeff;font-size:1.33em;">${Math.floor(player.score)}</span>`;

}, 900);

}

/* --- Crash flash --- */

function renderCrash(anim){

let p = Math.min(1,anim/0.41);

ctx.save();

ctx.globalAlpha = .57*(1-p); ctx.fillStyle="#fff";

ctx.fillRect(0,0,width,height);

ctx.globalAlpha = .22*p; ctx.fillStyle="#e14";

ctx.fillRect(0,0,width,height);

ctx.restore();

}

function gameLoop(now) {

if(player.dead) { renderCrash(crashAnim||0.5); return; }

let t = now/1000;

if (!lastFrame) lastFrame = t;

let dt = Math.max(0.008, Math.min(0.045, t-lastFrame));

lastFrame = t;

// Difficulty

asteroidInterval=880-Math.min(468,player.score*0.09);

debrisInterval=1190-Math.min(600,player.score*0.06);

enemyInterval=2410-Math.min(1100,player.score*0.05);

asteroidSpeed = 8.2 + player.score*0.0022;

// --- Player ship smooth movement ---

let aim = getAimDir();

player.x += aim.dx*player.v*dt*0.98;

player.y += aim.dy*player.v*dt*0.97;

player.z += aim.dz*player.v*dt*0.93;

// Clamp ship position

player.x = Math.max(-20, Math.min(20, player.x));

player.y = Math.max(-13, Math.min(13, player.y));

player.z = Math.max(3, Math.min(90, player.z));

// --- Spawns ---

const nowMs = now;

if(nowMs-lastAsteroid > asteroidInterval && asteroids.length < 6){

spawnAsteroid(); lastAsteroid = nowMs;

}

if(nowMs-lastDebris > debrisInterval && debris.length<7){

spawnDebris(); lastDebris = nowMs;

}

if(enemies.length<2 && nowMs-lastEnemy>enemyInterval){

spawnEnemy(); lastEnemy=nowMs;

}

// --- Update Entities ---

for(let a of asteroids){

a.x+=a.vx*dt; a.y+=a.vy*dt; a.z+=a.vz*dt;

}

for(let d of debris) {

d.x+=d.vx*dt; d.y+=d.vy*dt; d.z+=d.vz*dt;

}

for(let e of enemies) e.z+=e.speed*dt;

asteroids = asteroids.filter(a=>a.z>Z_NEAR && Math.abs(a.x-player.x)<30 && Math.abs(a.y-player.y)<19);

debris = debris.filter(d=>d.z>Z_NEAR && Math.abs(d.x-player.x)<33);

enemies = enemies.filter(e=>e.z>Z_NEAR && Math.abs(e.x-player.x)<29);

// --- Lasers ---

for(let l of lasers){

l.x+=l.dx*63*dt; l.y+=l.dy*63*dt; l.z+=l.dz*63*dt;

}

lasers = lasers.filter(l=>l.z>Z_NEAR&&l.z<Z_FAR);

// --- Collisions ---

// Laser-asteroid

for(let li=lasers.length-1;li>=0;li--){

let l=lasers[li];

for(let ai=asteroids.length-1;ai>=0;ai--){

let a=asteroids[ai];

if(segmentSphereHit(l,3,a,a.radius*0.9)){

player.score+=Math.floor(12*a.radius);

explosions.push({x:a.x,y:a.y,z:a.z,r:a.radius*1.5,age:0});

playExplosionSound(); asteroids.splice(ai,1); lasers.splice(li,1); break;

}

}

for(let ei=enemies.length-1;ei>=0;ei--){

let e=enemies[ei];

if(segmentSphereHit(l,2.9,e,e.radius*.89)){

e.health-=1; explosions.push({x:e.x,y:e.y,z:e.z,r:e.radius*2,age:0});

playExplosionSound(); player.score+=32; lasers.splice(li,1);

if(e.health<=0) enemies.splice(ei,1);

break;

}

}

}

for(let ex of explosions) ex.age+=dt;

explosions = explosions.filter(e=>e.age<.42);

// Ship/object

if(player.invuln<=0){

for(let a of asteroids){

if(sphereDistance(player,1.88,a,a.radius*0.90)<0){

crashAnim=0; explosions.push({x:a.x,y:a.y,z:a.z,r:a.radius*1.4,age:0});

playCrashSound(); setTimeout(()=>endGame("CRASHED INTO ASTEROID!"),800);

player.health = 0; player.dead=true; return;

}

}

for(let d of debris){

if(sphereDistance(player,1.57,d,d.radius*0.92)<0){

player.health -= .12; player.invuln=0.79;

if(player.health<=0){

crashAnim=0; explosions.push({x:d.x,y:d.y,z:d.z,r:d.radius*1.5,age:0});

playCrashSound(); setTimeout(()=>endGame("DESTROYED BY DEBRIS!"),700);

player.health=0; player.dead=true; return;

}

explosions.push({x:d.x,y:d.y,z:d.z,r:d.radius*1.3,age:0});

debris.splice(debris.indexOf(d),1);

}

}

for(let e of enemies){

if(sphereDistance(player,1.65,e,e.radius*0.89)<0){

crashAnim=0; explosions.push({x:e.x,y:e.y,z:e.z,r:e.radius*2,age:0});

playCrashSound(); setTimeout(()=>endGame("COLLIDED WITH ENEMY!"),880);

player.health = 0; player.dead=true; return;

}

}

} else { player.invuln-=dt;}

// --- HUD

healthBarInner.style.width = Math.max(0,player.health*100)+'%';

scoreField.innerText = `SCORE: ${Math.floor(player.score)}`;

// --- DRAW SCENE ---

ctx.clearRect(0,0,canvas.width,canvas.height);

renderStarfield(); renderAsteroids(); renderDebris(); renderEnemies(); renderLasers(); renderExplosions(); renderCockpit();

// Vignette

ctx.save();

let vGrd=ctx.createRadialGradient(width/2, height/2, height*0.61, width/2,height/2, height*1.12);

vGrd.addColorStop(0,"rgba(0,0,0,0)");

vGrd.addColorStop(1,"rgba(0,0,0,0.23)");

ctx.globalAlpha=1; ctx.fillStyle=vGrd; ctx.fillRect(0,0,width,height);

ctx.restore();

updateCrosshairPosition();

// Crash overlay

if(player.dead){ renderCrash(crashAnim||0); return;}

if(crashAnim!==null){ crashAnim+=dt; if(crashAnim>0.49) crashAnim=null; }

requestAnimationFrame(gameLoop);

}

resetGame();

</script>

</body>

</html>
